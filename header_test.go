package haproxy

import (
	"bytes"
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
)

var encodedHeaders = [][]byte{
	{ // Normal IPv4 TCP header
		0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c,
		0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01, 0xa5, 0xce, 0x05, 0x3a,
	},
	{ // Normal IPv6 UDP header
		0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00, 0x24,
		0x23, 0x45, 0x04, 0x25, 0x2c, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x05, 0x67, 0x56, 0x73, 0x23, 0xb5,
		0x26, 0x07, 0xf0, 0xd0, 0x10, 0x02, 0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
		0x7d, 0x33, 0x01, 0xbb,
	},
	{ // Header with broken signature
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c,
		0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01, 0xa5, 0xce, 0x05, 0x3a,
	},
	{ // Unsupported protocol with 8 bytes of excessive data
		0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x00, 0x00, 0x20,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	},
}

var decodeTests = []func(t *testing.T, header *Header, read int, err error){
	// Normal IPv4 TCP header
	func(t *testing.T, header *Header, read int, err error) {
		assert.Equal(t, 28, read)
		assert.Equal(t, CommandPROXY, header.Command)
		assert.NotNil(t, header.ProxyAddress)

		addr := header.ProxyAddress.(*IPv4Address)
		assert.Equal(t, &net.TCPAddr{IP: []byte{127, 0, 0, 1}, Port: 42446}, addr.SourceAddr)
		assert.Equal(t, &net.TCPAddr{IP: []byte{127, 0, 0, 1}, Port: 1338}, addr.DestinationAddr)
	},

	// Normal IPv6 UDP header
	func(t *testing.T, header *Header, read int, err error) {
		assert.Equal(t, 52, read)
		assert.Equal(t, CommandPROXY, header.Command)
		assert.NotNil(t, header.ProxyAddress)

		source := net.ParseIP("2345:0425:2CA1::0567:5673:23b5")
		destination := net.ParseIP("2607:f0d0:1002:51::4")

		addr := header.ProxyAddress.(*IPv6Address)
		assert.Equal(t, &net.UDPAddr{IP: source, Port: 32051}, addr.SourceAddr)
		assert.Equal(t, &net.UDPAddr{IP: destination, Port: 443}, addr.DestinationAddr)
	},

	// Header with broken signature
	func(t *testing.T, header *Header, read int, err error) {
		assert.Equal(t, 12, read)
		assert.NotNil(t, err)
		assert.IsType(t, &ProxyProtocolError{}, err)
	},

	// Unsupported protocol with 8 bytes of excessive data
	func(t *testing.T, header *Header, read int, err error) {
		assert.Equal(t, 48, read)
		assert.Equal(t, CommandPROXY, header.Command)
		assert.Nil(t, header.ProxyAddress)
		assert.IsType(t, &TransportProtocolError{}, err)
	},
}

func TestHeader_ReadFrom(t *testing.T) {
	for i, data := range encodedHeaders {
		reader := bytes.NewReader(data)

		var header Header
		n, err := header.ReadFrom(reader)

		test := decodeTests[i]
		test(t, &header, int(n), err)
	}
}

var headers = []*Header{
	{
		Command: CommandPROXY,
		ProxyAddress: &IPv4Address{
			SourceAddr:      &net.TCPAddr{IP: []byte{127, 0, 0, 1}, Port: 42446},
			DestinationAddr: &net.TCPAddr{IP: []byte{127, 0, 0, 1}, Port: 1338},
		},
	},
	{
		Command: CommandPROXY,
		ProxyAddress: &IPv6Address{
			SourceAddr:      &net.UDPAddr{IP: net.ParseIP("2345:0425:2CA1::0567:5673:23b5"), Port: 56724},
			DestinationAddr: &net.UDPAddr{IP: net.ParseIP("2607:f0d0:1002:51::4"), Port: 8080},
		},
	},
}

var expectedEncodedHeaders = [][]byte{
	{
		0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c,
		0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01, 0xa5, 0xce, 0x05, 0x3a,
	},
	{
		0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00, 0x24,
		0x23, 0x45, 0x04, 0x25, 0x2c, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x05, 0x67, 0x56, 0x73, 0x23, 0xb5,
		0x26, 0x07, 0xf0, 0xd0, 0x10, 0x02, 0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
		0xdd, 0x94, 0x1f, 0x90,
	},
}

func TestHeader_WriteTo(t *testing.T) {
	for i, header := range headers {
		buffer := &bytes.Buffer{}
		n, err := header.WriteTo(buffer)

		expected := expectedEncodedHeaders[i]
		assert.Nil(t, err)
		assert.Equal(t, len(expected), int(n))
		assert.Equal(t, expected, buffer.Bytes())
	}
}
